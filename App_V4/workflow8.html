<!DOCTYPE html>
<html lang="en">
<head>
<script>
(function(){
  try{
    var qs = new URLSearchParams(location.search);
    if (qs.get('from') === 'photo' || qs.get('slot')){
      document.documentElement.classList.add('from-photo');
    }
  }catch(e){}
})();
</script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#0b1220">
    <link rel="manifest" href="manifest.json">
    <title>Pro Occlusal Analysis (Aligner Ready)</title>
    <style>
        * { box-sizing: border-box; font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; }
        
        body {
            margin: 0; padding: 0;
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            color: #333;
            min-height: 100vh;
            overflow: hidden;
        }
        
        .app-container {
            display: flex;
            height: 100vh;
            width: 100vw;
            background: #f8fafc;
        }
        
        /* Sidebar Styling */
        .sidebar {
            width: 320px;
            background: #111827;
            color: #f3f4f6;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #374151;
            flex-shrink: 0;
            z-index: 10;
        }

        .sidebar-header {
            padding: 20px;
            background: #1f2937;
            border-bottom: 1px solid #374151;
        }
        .sidebar-header h2 { margin: 0; font-size: 18px; color: #60a5fa; display: flex; align-items: center; gap: 8px; }
        .sidebar-subtitle { font-size: 11px; color: #9ca3af; margin-top: 5px; }

        .points-section { padding: 15px; flex: 1; overflow-y: auto; }
        .section-title { font-size: 12px; font-weight: 700; color: #9ca3af; text-transform: uppercase; margin-bottom: 10px; display: flex; justify-content: space-between; }
        
        .points-list { list-style: none; padding: 0; margin: 0; }
        .point-item {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            padding: 12px;
            margin-bottom: 8px;
            border-radius: 8px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: space-between;
            color: #d1d5db;
        }
        .point-item:hover { background: rgba(255,255,255,0.1); }
        .point-item.optional { border-style: dashed; opacity: 0.85; }
        .point-item.active { border-color: #60a5fa; background: rgba(59, 130, 246, 0.2); color: white; }
        .point-item.done { border-left: 3px solid #10b981; }
        .point-item.missing { border-left: 3px solid #ef4444; background: rgba(239, 68, 68, 0.1); }
        .point-marker { width: 12px; height: 12px; border-radius: 50%; display: inline-block; margin-right: 10px; border: 2px solid rgba(255,255,255,0.8); }

        /* BUTTONS STYLING */
        .sidebar-controls {
            padding: 20px;
            background: #0f172a;
            border-top: 1px solid #374151;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .btn {
            border: none; padding: 14px; border-radius: 12px; cursor: pointer; 
            font-weight: 600; font-size: 14px; text-align: center;
            transition: transform 0.1s, box-shadow 0.2s; 
            width: 100%; display: block;
            color: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }
        .btn:active { transform: translateY(1px); box-shadow: none; }

        .btn-undo { background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.1); font-size: 13px; padding: 10px; margin-bottom: 5px; }
        .btn-blue { background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); }
        .btn-dark { background: #1f2937; border: 1px solid #374151; color: #e5e7eb; }
        .btn-purple { background: linear-gradient(135deg, #a855f7 0%, #7e22ce 100%); }
        .btn-orange { background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); }
        .btn-red { background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); }

        .btn:hover { filter: brightness(1.1); }

        /* Main Content */
        .main-content { flex: 1; display: flex; flex-direction: column; overflow: hidden; position: relative; background: #cbd5e1; }
        
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            cursor: grab;
            display: flex;
            justify-content: center;
            align-items: center;
            background: radial-gradient(#e2e8f0 1px, transparent 1px);
            background-size: 20px 20px;
        }
        .canvas-container:active { cursor: grabbing; }
        
        #face-canvas { 
            display: block; 
            max-width: 100%;
            max-height: 100%;
        }
        
        /* Analysis Panel */
        .analysis-panel {
            width: 360px;
            background: white;
            border-left: 1px solid #e2e8f0;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            box-shadow: -5px 0 15px rgba(0,0,0,0.05);
            z-index: 20;
        }
        
        .panel-header { padding: 20px; border-bottom: 1px solid #e2e8f0; background: #f8fafc; }
        .panel-header h3 { margin: 0; font-size: 16px; color: #1e293b; }

        .metric-group { padding: 15px 20px; border-bottom: 1px solid #f1f5f9; }
        .metric-label { font-size: 12px; font-weight: 600; color: #64748b; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px; }
        
        .metric-card {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
        }
        .metric-card.highlight { border-left: 3px solid #3b82f6; }
        .metric-card.alert { border-left: 3px solid #ef4444; }
        
        .m-row { display: flex; justify-content: space-between; align-items: baseline; margin-bottom: 4px; }
        .m-title { font-size: 14px; font-weight: 600; color: #334155; }
        .m-val { font-size: 15px; font-weight: 700; color: #0f172a; }
        .m-sub { font-size: 11px; color: #94a3b8; }
        
        .tag { padding: 2px 6px; border-radius: 4px; font-size: 10px; font-weight: 700; color: white; }
        .tag.green { background: #10b981; }
        .tag.blue { background: #3b82f6; }
        .tag.orange { background: #f59e0b; }
        .tag.red { background: #ef4444; }
        .tag.purple { background: #8b5cf6; }

        /* Progress (Delta) Styling */
        .delta-val { font-size: 11px; font-weight: 700; margin-left: 6px; display: inline-block; padding: 2px 4px; border-radius: 4px; background: #f1f5f9; }
        .delta-pos { color: #10b981; }
        .delta-neg { color: #ef4444; }
        
        /* Upload Overlay */
        .upload-overlay {
            position: absolute; inset: 0; background: rgba(241, 245, 249, 0.95);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 50;
        }
        .upload-box {
            background: white; padding: 40px; border-radius: 20px; text-align: center;
            box-shadow: 0 20px 50px rgba(0,0,0,0.1); border: 2px dashed #cbd5e1;
        }

        /* Modal */
        .modal { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 100; backdrop-filter: blur(2px); }
        .modal-content {
            background: white; width: 450px; margin: 10% auto; padding: 25px; border-radius: 12px;
            box-shadow: 0 25px 50px rgba(0,0,0,0.25);
            max-height: 80vh; overflow-y: auto;
        }
        .input-group { margin-bottom: 15px; }
        .input-group label { display: block; margin-bottom: 5px; font-size: 13px; font-weight: 600; }
        .input-group input { width: 100%; padding: 10px; border: 1px solid #cbd5e1; border-radius: 6px; }

        /* Reference Images */
        .ref-grid { display: grid; gap: 10px; margin-top: 10px; }
        .ref-item { border: 1px solid #eee; padding: 10px; border-radius: 8px; }
        .ref-title { font-weight: bold; font-size: 13px; color: #3b82f6; }
        .ref-desc { font-size: 12px; color: #666; margin-top: 2px; }

        /* Baseline Action */
        .baseline-action {
            margin-top: 10px; padding-top: 10px; border-top: 1px dashed #e2e8f0;
            text-align: center;
        }
        .btn-set-base {
            background: transparent; border: 1px solid #10b981; color: #10b981;
            padding: 6px 12px; border-radius: 20px; font-size: 11px; cursor: pointer;
            transition: all 0.2s;
        }
        .btn-set-base:hover { background: #10b981; color: white; }

        /* Zoom Hints */
        .canvas-controls-hint {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.6); color: white; padding: 6px 12px; border-radius: 20px;
            font-size: 12px; pointer-events: none; z-index: 10;
        }

        /* Context Menu */
        .context-menu {
            position: absolute;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            z-index: 1000;
            min-width: 150px;
            display: none;
        }
        .context-menu-item {
            padding: 10px 15px;
            cursor: pointer;
            font-size: 13px;
            color: #334155;
            display: flex;
            align-items: center;
            gap: 8px;
            border-bottom: 1px solid #f1f5f9;
        }
        .context-menu-item:last-child { border-bottom: none; }
        .context-menu-item:hover { background: #f8fafc; }
        .context-menu-item.missing { color: #ef4444; }

        /* Measurement lines */
        .measurement-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
            pointer-events: none;
            z-index: 30;
            white-space: nowrap;
        }

        /* Point editing cursor */
        .point-editing {
            cursor: move !important;
        }

    

/* Unified Calibration Modal Theme */
#calibration-modal.modal, #calib-settings-modal.modal{
  display:none;
  position:fixed;
  z-index:1000;
  left:0; top:0;
  width:100%; height:100%;
  background: rgba(0,0,0,0.80);
  backdrop-filter: blur(5px);
  overflow:auto;
}
#calibration-modal .calib-unified, #calib-settings-modal .calib-unified{
  background:#ffffff !important;
  margin:50px auto !important;
  padding:0 !important;
  border-radius:20px !important;
  width:90% !important;
  max-width:600px !important;
  box-shadow:0 20px 40px rgba(0,0,0,0.20) !important;
  overflow:hidden !important;
  position:relative !important;
}
.calib-unified .modal-header{
  background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d) !important;
  color:#ffffff !important;
  padding:20px 30px !important;
  display:flex !important;
  align-items:center !important;
  justify-content:space-between !important;
  gap:16px !important;
}
.calib-unified .modal-header h2,
.calib-unified .modal-header h3{
  margin:0 !important;
  font-size:20px !important;
  font-weight:700 !important;
  color:#ffffff !important;
}
.calib-unified .close-modal,
.calib-unified .close-calib{
  color:#ffffff !important;
  font-size:28px !important;
  font-weight:700 !important;
  cursor:pointer !important;
  background:transparent !important;
  border:0 !important;
  line-height:1 !important;
}
.calib-unified .modal-body{
  padding:25px 30px !important;
}
.calib-unified .modal-subtitle{
  margin:0 0 10px 0 !important;
  color:#475569 !important;
  font-size:13px !important;
}
.calib-unified .calibration-options,
.calib-unified .calib-grid{
  display:flex !important;
  gap:20px !important;
  margin:18px 0 0 0 !important;
  flex-wrap:wrap !important;
}
.calib-unified .calibration-option,
.calib-unified .calib-card{
  flex:1 1 240px !important;
  background:#f8f9fa !important;
  border-radius:15px !important;
  padding:20px !important;
  cursor:pointer !important;
  border:2px solid transparent !important;
  transition: all 0.25s ease !important;
  box-shadow:0 10px 20px rgba(0,0,0,0.06) !important;
}
.calib-unified .calibration-option:hover,
.calib-unified .calib-card:hover{
  transform: translateY(-3px) !important;
  box-shadow:0 15px 30px rgba(0,0,0,0.10) !important;
}
.calib-unified .calibration-option.selected,
.calib-unified .calib-card.selected{
  border-color:#b21f1f !important;
  background:#fff4f4 !important;
}
.calib-unified .calibration-icon,
.calib-unified .calib-icon{
  width:60px !important;
  height:60px !important;
  border-radius:50% !important;
  background: linear-gradient(135deg, #1a2a6c, #b21f1f) !important;
  color:#ffffff !important;
  display:flex !important;
  align-items:center !important;
  justify-content:center !important;
  margin:0 auto 15px auto !important;
  font-size:24px !important;
}
.calib-unified h3, .calib-unified .calib-card-title{
  margin:0 0 8px 0 !important;
  text-align:center !important;
  font-size:16px !important;
  color:#0f172a !important;
}
.calib-unified p, .calib-unified .calib-card-desc{
  margin:0 !important;
  text-align:center !important;
  color:#475569 !important;
  font-size:13px !important;
}
.calib-unified .calibration-input,
.calib-unified .calib-manual-input,
.calib-unified .calib-fields{
  margin-top:14px !important;
  background:#ffffff !important;
  border-radius:12px !important;
  padding:14px !important;
  border:1px solid #e2e8f0 !important;
}
.calib-unified label{
  display:block !important;
  font-size:13px !important;
  color:#334155 !important;
  margin-bottom:6px !important;
}
.calib-unified input[type="number"],
.calib-unified input[type="text"]{
  width:100% !important;
  padding:12px !important;
  border:2px solid #e2e8f0 !important;
  border-radius:10px !important;
  font-size:14px !important;
}
.calib-unified .calib-inline{
  display:flex !important;
  gap:10px !important;
  align-items:center !important;
}
.calib-unified .calib-help{
  margin-top:8px !important;
  font-size:12px !important;
  color:#64748b !important;
}
.calib-unified .modal-footer,
.calib-unified .modal-actions,
.calib-unified .calib-actions{
  display:flex !important;
  justify-content:flex-end !important;
  gap:12px !important;
  padding:0 30px 25px 30px !important;
}
.calib-unified .btn{
  border-radius:12px !important;
}
.calib-unified .calib-radio-row{
  display:flex !important;
  gap:8px !important;
  align-items:center !important;
  justify-content:center !important;
  margin-top:12px !important;
  font-size:13px !important;
  color:#334155 !important;
}


/* === RRZ User Notes Panel (added) === */
.user-notes-panel{
  max-width: 900px;
  margin: 12px auto 0;
  background: #fff;
  border: 3px solid #111;
  border-radius: 18px;
  padding: 18px 18px 12px;
  box-shadow: 0 10px 24px rgba(0,0,0,0.08);
}
.user-notes-panel .notes-title{
  font-size: 22px;
  font-weight: 800;
  margin: 0 0 12px;
  color:#111;
}
.user-notes-panel .note-row{
  display:flex;
  align-items:center;
  gap: 12px;
  margin: 14px 0;
}
.user-notes-panel .note-label{
  min-width: 170px;
  font-size: 22px;
  font-weight: 800;
  color: #7b7b7b;
}
.user-notes-panel input,
.user-notes-panel textarea{
  flex:1;
  font-size: 16px;
  border: none;
  border-bottom: 2px dashed #777;
  padding: 6px 6px;
  outline: none;
  background: transparent;
}
.user-notes-panel textarea{
  border: 2px dashed #777;
  border-radius: 10px;
  min-height: 70px;
  resize: vertical;
}
.user-notes-panel .notes-hint{
  margin-top: 10px;
  font-size: 12px;
  color: #64748b;
}

</style>
    <!-- Add jsPDF library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
</head>
<body>

<div class="app-container">
    
    <!-- LEFT SIDEBAR: Controls & Landmarks -->
    <div class="sidebar">
        <div class="sidebar-header">
            <h2><i>ü¶∑</i> Occlusal AI</h2>
            <div class="sidebar-subtitle">Advanced Arch Form & Occlusal Analysis</div>
        </div>

        <div class="points-section">
            <div class="section-title">
                <span>Landmarks (17 required + 2 optional)</span>
                <span id="points-counter">0/17</span>
            </div>
            <ul class="points-list" id="points-list">
                <!-- Generated by JS -->
            </ul>
        </div>

        <div class="sidebar-controls">
            <button class="btn btn-undo" onclick="undoPoint()">Undo Point Placement</button>
            <button class="btn btn-blue" onclick="analyze()">Complete Analysis</button>
            <button class="btn btn-dark" onclick="openCalibrationSettings(true)">Calibration</button>
            <button class="btn btn-purple" onclick="openRefGuide()">Reference Guide</button>
            <button class="btn btn-red" onclick="exportPDF()">Export PDF Report</button>
            
            <div style="text-align:center; margin-top:5px;">
                <button onclick="document.getElementById('file-input').click()" style="background:none; border:none; color:#6b7280; font-size:11px; cursor:pointer; text-decoration:underline;">Change Image</button>
                <span style="color:#4b5563; margin:0 5px;">|</span>
                <button onclick="resetAll()" style="background:none; border:none; color:#ef4444; font-size:11px; cursor:pointer; text-decoration:underline;">Reset All</button>
            </div>
        </div>
    </div>

    <!-- CENTER: Canvas Area -->
    <div class="main-content">
        <div class="canvas-container" id="canvas-wrapper">
            <canvas id="face-canvas"></canvas>
            
            <div class="upload-overlay" id="upload-overlay">
                <div class="upload-box">
                    <h2 style="margin-top:0;">Upload Occlusal Photo</h2>
                    <p style="color:#64748b; font-size:14px; margin-bottom:20px;">Support for JPG, PNG. Ensure occlusal view.</p>
                    <button class="btn btn-blue" style="width:auto; display:inline-block; padding:12px 30px;" onclick="document.getElementById('file-input').click()">Select Image</button>
                </div>
            </div>
            
            <div class="canvas-controls-hint">
                Wheel to Zoom ‚Ä¢ Drag to Pan ‚Ä¢ Click to Place ‚Ä¢ Drag Points to Move ‚Ä¢ Right-click for options
            </div>
        

        <!-- RRZ_USER_NOTES_PANEL_START -->
        <div class="user-notes-panel" id="user-notes-panel" style="display:none;">
            <div class="notes-title">Notes:</div>
            <div class="note-row">
                <div class="note-label">Crowding</div>
                <input id="note-crowding" type="text" placeholder="">
            </div>
            <div class="note-row">
                <div class="note-label">Gingival Margin</div>
                <input id="note-gingival-margin" type="text" placeholder="">
            </div>
            <div class="note-row">
                <div class="note-label">Gingival color</div>
                <input id="note-gingival-color" type="text" placeholder="">
            </div>
            <div class="note-row" style="align-items:flex-start;">
                <div class="note-label" style="padding-top:6px;">Other Findings</div>
                <textarea id="note-other-findings" placeholder=""></textarea>
            </div>
            <div class="notes-hint">These notes will be appended automatically at the end of the final report.</div>
        </div>
        <!-- RRZ_USER_NOTES_PANEL_END -->
</div>
    </div>

    <!-- RIGHT: Analysis Results -->
    <div class="analysis-panel">
        <div class="panel-header">
            <h3>Analysis Report</h3>
            <div style="font-size:12px; color:#64748b;" id="calib-indicator">Uncalibrated (px)</div>
        </div>

        <div id="results-container" style="display:none;">
            <!-- 1. Arch Form & Shape -->
            <div class="metric-group">
                <div class="metric-label">Arch Form & Shape</div>
                <div class="metric-card highlight">
                    <div class="m-row">
                        <div class="m-title">Arch Form Type</div>
                        <div class="tag blue" id="arch-form-tag">--</div>
                    </div>
                    <div class="m-sub" id="arch-ratio-val">Width/Depth Ratio: --</div>
                    <div class="m-sub" style="margin-top:4px; font-style:italic;" id="arch-rec">Shape: --</div>
                </div>
                <div class="metric-card" id="deformity-card">
                    <div class="m-row">
                        <div class="m-title">Arch Deformity</div>
                        <div class="tag green" id="deformity-tag">--</div>
                    </div>
                    <div class="m-sub" id="deformity-desc">Based on symmetry analysis</div>
                </div>
            </div>

            <!-- 2. Width Measurements -->
            <div class="metric-group">
                <div class="metric-label">Width Measurements</div>
                <div class="metric-card">
                    <div class="m-row">
                        <div class="m-title">Intercanine Width</div>
                        <div class="m-val" id="icw-val">--</div>
                    </div>
                    <div class="m-sub">Canine to Canine distance</div>
                </div>
                <div class="metric-card">
                    <div class="m-row">
                        <div class="m-title">Intermolar Width (Fossa)</div>
                        <div class="m-val" id="imw-val">--</div>
                    </div>
                    <div class="m-sub">Molar fossa to fossa</div>
                </div>
                <div class="metric-card">
                    <div class="m-row">
                        <div class="m-title">Intermolar Width (Cusp)</div>
                        <div class="m-val" id="imw-cusp-val">--</div>
                    </div>
                    <div class="m-sub">Mesio-buccal cusp to cusp</div>
                </div>
                <div class="metric-card">
                    <div class="m-row">
                        <div class="m-title">Premolar Width</div>
                        <div class="m-val" id="pmw-val">--</div>
                    </div>
                    <div class="m-sub">First Premolar distance</div>
                </div>
            </div>

            <!-- 3. Midline Measurements -->
            <div class="metric-group">
                <div class="metric-label">Midline Measurements</div>
                <div class="metric-card">
                    <div class="m-row">
                        <div class="m-title">Dental to Posterior</div>
                        <div class="m-val" id="midline-length-val">--</div>
                    </div>
                    <div class="m-sub">Dental midline to posterior raphe</div>
                </div>
                <div class="metric-card alert" id="midline-card">
                    <div class="m-row">
                        <div class="m-title">Midline Deviation</div>
                        <div class="m-val" id="midline-val">--</div>
                    </div>
                    <div class="m-sub" id="midline-dir">Direction: --</div>
                </div>
                <div class="metric-card">
                    <div class="m-row">
                        <div class="m-title">Arch Symmetry Index</div>
                        <div class="m-val" id="sym-val">--%</div>
                    </div>
                    <div class="m-sub">Higher = better symmetry</div>
                </div>
            </div>
            
            <!-- 4. Missing Teeth -->
            <div class="metric-group" id="missing-teeth-section" style="display:none;">
                <div class="metric-label">Missing Teeth Analysis</div>
                <div class="metric-card alert">
                    <div class="m-row">
                        <div class="m-title">Missing Teeth Count</div>
                        <div class="m-val" id="missing-count">0</div>
                    </div>
                    <div class="m-sub" id="missing-list">None</div>
                </div>
            </div>

            <!-- 5. Recommendations -->
            <div class="metric-group">
                <div class="metric-label">Clinical Recommendations</div>
                <div class="metric-card">
                    <div class="m-sub" id="recommendations" style="line-height:1.4;">
                        Complete analysis to see recommendations.
                    </div>
                </div>
            </div>

        </div>
        
        <div id="empty-state" style="padding:40px; text-align:center; color:#94a3b8;">
            Place all landmarks to see analysis results.
        </div>
    </div>
</div>

<!-- Inputs -->
<input type="file" id="file-input" hidden accept="image/*">

<!-- Context Menu -->
<div class="context-menu" id="context-menu">
    <div class="context-menu-item" onclick="markAsMissing()">
        <span style="color:#ef4444;">‚úï</span> Mark as Missing Tooth
    </div>
    <div class="context-menu-item" onclick="editPoint()">
        <span>‚úèÔ∏è</span> Edit This Point
    </div>
    <div class="context-menu-item" onclick="deletePoint()">
        <span>üóëÔ∏è</span> Delete This Point
    </div>
</div>

<!-- Calibration Settings Modal -->
<div class="modal" id="calib-settings-modal" style="display:none;">
  <div class="modal-content calib-unified" role="dialog" aria-modal="true" aria-labelledby="calibSettingsTitle">
    <div class="modal-header">
      <h2 id="calibSettingsTitle">Calibration Settings</h2>
      <button class="close-modal" type="button" aria-label="Close" onclick="closeCalibrationSettings()">&times;</button>
    </div>

    <div class="modal-body">
      <p class="modal-subtitle" id="calib-settings-hint">Select a calibration method. You can calibrate now or later before analysis.</p>

      <div class="calibration-options">
        <div class="calibration-option selected" id="calib-opt-manual" onclick="document.querySelector('input[name=calib-method][value=manual]').checked=true; updateCalibSettingsUI();">
          <div class="calibration-icon">üìè</div>
          <h3>Manual (mm)</h3>
          <p>Use two anatomical/dental points on the image to set a real-world scale.</p>
          <div class="calib-radio-row">
            <input type="radio" name="calib-method" value="manual" checked onchange="updateCalibSettingsUI()">
            <span>Select Manual</span>
          </div>
        </div>

        <div class="calibration-option" id="calib-opt-pixel" onclick="document.querySelector('input[name=calib-method][value=pixel]').checked=true; updateCalibSettingsUI();">
          <div class="calibration-icon">üî¢</div>
          <h3>Pixel (px/mm)</h3>
          <p>Enter the scale directly as pixels per millimeter.</p>
          <div class="calib-radio-row">
            <input type="radio" name="calib-method" value="pixel" onchange="updateCalibSettingsUI()">
            <span>Select Pixel</span>
          </div>
        </div>
      </div>

      <div id="pixel-calib-fields" class="calib-fields" style="display:none;">
        <div class="input-group">
          <label>Scale (px per mm)</label>
          <div class="calib-inline">
            <input type="number" id="px-per-mm" placeholder="e.g., 6.25" step="0.0001">
            <button class="btn btn-dark" onclick="invertPxMm()" type="button">Invert</button>
          </div>
          <div class="calib-help">If you have mm/px instead, enter it then click Invert to convert to px/mm.</div>
        </div>
      </div>
    </div>

    <div class="modal-footer">
      <button class="btn btn-dark" type="button" onclick="closeCalibrationSettings()">Close</button>
      <button class="btn btn-blue" type="button" onclick="applyCalibrationSettings()">Apply</button>
    </div>
  </div>
</div>


<!-- Calibration Modal --><!-- Calibration Modal -->
<div class="modal" id="calib-modal">
    <div class="modal-content">
        <h3 style="margin-top:0;">Calibration</h3>
        <p style="font-size:13px; color:#64748b;">Enter the real-world distance between two known points.</p>
        
        <div class="input-group">
            <label>Measured Distance (mm)</label>
            <input type="number" id="known-mm" placeholder="e.g., 35 for ICW or 45 for IMW">
        </div>
        <div class="input-group">
            <label>Reference Points used:</label>
            <select id="calib-ref-type" style="width:100%; padding:8px;">
                <option value="icw">Intercanine Width (Canines)</option>
                <option value="imw">Intermolar Width (First Molars Fossa)</option>
                <option value="imw-cusp">Intermolar Width (Mesio-buccal Cusps)</option>
                <option value="midline">Midline Length (Dental to Posterior)</option>
            </select>
        </div>
        
        <div style="display:flex; justify-content:flex-end; gap:10px;">
            <button class="btn btn-undo" style="width:auto; color:#333;" onclick="closeModal('calib-modal')">Cancel</button>
            <button class="btn btn-blue" style="width:auto; padding:10px 20px;" onclick="applyCalibration()">Apply</button>
        </div>
    </div>
</div>

<!-- Reference Guide Modal -->
<div class="modal" id="ref-modal">
    <div class="modal-content">
        <h3 style="margin-top:0; color:#7e22ce;">Landmark Guide (19 Points ‚Äî 17 required + 2 optional)</h3>
        <div class="ref-image" style="margin:10px 0 6px 0;">
            <img src="referance image8.png" alt="Reference" style="width:100%; max-width:520px; border-radius:12px; border:1px solid #e5e7eb;" onerror="this.style.display='none'">
        </div>
        <div class="ref-grid">
            <div class="ref-item">
                <div class="ref-title">1. Midline Posterior (Raphe)</div>
                <div class="ref-desc">Center of the palate back or lingual frenum.</div>
            </div>
            <div class="ref-item">
                <div class="ref-title">2. Midline Anterior (Papilla)</div>
                <div class="ref-desc">Center of the incisive papilla or midline structure.</div>
            </div>
            <div class="ref-item">
                <div class="ref-title">3. Dental Midline</div>
                <div class="ref-desc">Contact point between the two central incisors.</div>
            </div>
            <!-- Right Side -->
            <div class="ref-item">
                <div class="ref-title">4. R Central Incisor Edge</div>
                <div class="ref-desc">Incisal edge of right central incisor.</div>
            </div>
            <div class="ref-item">
                <div class="ref-title">5. R Lateral Incisor Edge</div>
                <div class="ref-desc">Incisal edge of right lateral incisor.</div>
            </div>
            <div class="ref-item">
                <div class="ref-title">6. R Canine Incisal Edge</div>
                <div class="ref-desc">Cusp tip of right canine.</div>
            </div>
            <div class="ref-item">
                <div class="ref-title">7. R 1st Premolar Fossa</div>
                <div class="ref-desc">Central fossa of right first premolar.</div>
            </div>
            <div class="ref-item">
                <div class="ref-title">8. R 2nd Premolar Fossa</div>
                <div class="ref-desc">Central fossa of right second premolar.</div>
            </div>
            <div class="ref-item">
                <div class="ref-title">9. R 1st Molar Fossa</div>
                <div class="ref-desc">Central fossa of right first molar.</div>
            </div>
            <div class="ref-item">
                <div class="ref-title">10. R 1st Molar Cusp</div>
                <div class="ref-desc">Mesio-buccal cusp of right first molar.</div>
            </div>
            <!-- Left Side -->
            <div class="ref-item">
                <div class="ref-title">11. L Central Incisor Edge</div>
                <div class="ref-desc">Incisal edge of left central incisor.</div>
            </div>
            <div class="ref-item">
                <div class="ref-title">12. L Lateral Incisor Edge</div>
                <div class="ref-desc">Incisal edge of left lateral incisor.</div>
            </div>
            <div class="ref-item">
                <div class="ref-title">13. L Canine Incisal Edge</div>
                <div class="ref-desc">Cusp tip of left canine.</div>
            </div>
            <div class="ref-item">
                <div class="ref-title">14. L 1st Premolar Fossa</div>
                <div class="ref-desc">Central fossa of left first premolar.</div>
            </div>
            <div class="ref-item">
                <div class="ref-title">15. L 2nd Premolar Fossa</div>
                <div class="ref-desc">Central fossa of left second premolar.</div>
            </div>
            <div class="ref-item">
                <div class="ref-title">16. L 1st Molar Fossa</div>
                <div class="ref-desc">Central fossa of left first molar.</div>
            </div>
            <div class="ref-item">
                <div class="ref-title">17. L 1st Molar Cusp</div>
                <div class="ref-desc">Mesio-buccal cusp of left first molar.</div>
                        <div class="ref-item">
                <div class="ref-title">18. R 2nd Molar Fossa (Optional)</div>
                <div class="ref-desc">Central fossa of right second molar (optional).</div>
            </div>
            <div class="ref-item">
                <div class="ref-title">19. L 2nd Molar Fossa (Optional)</div>
                <div class="ref-desc">Central fossa of left second molar (optional).</div>
            </div>
</div>
        </div>
        <button class="btn btn-undo" style="width:100%; margin-top:20px; color:#333;" onclick="closeModal('ref-modal')">Close Guide</button>
    </div>
</div>

<script>
/**
 * ADVANCED OCCLUSAL ANALYSIS ENGINE
 * Version 4.0 - With curve drawing, additional lines, and measurements
 */

// --- CONFIGURATION ---
const LANDMARKS = [
    // Midline points
    { id: 'mid_post', name: '1. Midline Posterior (Raphe)', color: '#94a3b8' },
    { id: 'mid_ant',  name: '2. Midline Anterior (Papilla)', color: '#94a3b8' },
    { id: 'mid_dent', name: '3. Dental Midline', color: '#ef4444' },
    
    // Right side teeth (points 4-10)
    { id: 'r_ci', name: '4. R Central Incisor', color: '#3b82f6' },
    { id: 'r_li', name: '5. R Lateral Incisor', color: '#3b82f6' },
    { id: 'r_c',  name: '6. R Canine', color: '#3b82f6' },
    { id: 'r_p1', name: '7. R 1st Premolar', color: '#f59e0b' },
    { id: 'r_p2', name: '8. R 2nd Premolar', color: '#f59e0b' },
    { id: 'r_m1_fossa', name: '9. R 1st Molar Fossa', color: '#10b981' },
    { id: 'r_m1_cusp', name: '10. R Molar Cusp (MB)', color: '#8b5cf6' },
    
    // Left side teeth (points 11-17)
    { id: 'l_ci', name: '11. L Central Incisor', color: '#ef4444' },
    { id: 'l_li', name: '12. L Lateral Incisor', color: '#ef4444' },
    { id: 'l_c',  name: '13. L Canine', color: '#ef4444' },
    { id: 'l_p1', name: '14. L 1st Premolar', color: '#f59e0b' },
    { id: 'l_p2', name: '15. L 2nd Premolar', color: '#f59e0b' },
    { id: 'l_m1_fossa', name: '16. L 1st Molar Fossa', color: '#10b981' },
    { id: 'l_m1_cusp', name: '17. L Molar Cusp (MB)', color: '#8b5cf6' },

    // Optional posterior points (2nd molar fossae)
    { id: 'r_m2_fossa', name: '18. R 2nd Molar Fossa (Optional)', color: '#10b981', optional: true },
    { id: 'l_m2_fossa', name: '19. L 2nd Molar Fossa (Optional)', color: '#10b981', optional: true }
];


const REQUIRED_COUNT = LANDMARKS.filter(l => !l.optional).length;

// Viewport Transform State
const view = {
    scale: 1,
    offsetX: 0,
    offsetY: 0,
    isDragging: false,
    lastX: 0,
    lastY: 0,
    startX: 0,
    startY: 0
};

// Application State
const state = {
    img: null,
    points: [],
    currIdx: 0,
    ppm: 0,
    baseline: null,
    missingTeeth: new Array(LANDMARKS.length).fill(false),
    editingPoint: null,
    draggingPoint: null, // For point movement
    canvas: document.getElementById('face-canvas'),
    ctx: null,
    archPoints: [],
    canvasWidth: 0,
    canvasHeight: 0,
    showMeasurements: false,
    measurements: []
};

// Context Menu State
let contextMenuPoint = null;

// --- INITIALIZATION ---
function init() {
    state.points = new Array(LANDMARKS.length).fill(null);
    state.currIdx = 0;
    state.ppm = 0;
    view.scale = 1;
    view.offsetX = 0;
    view.offsetY = 0;
    state.missingTeeth = new Array(LANDMARKS.length).fill(false);
    state.draggingPoint = null;
    state.measurements = [];
    
    // Initialize canvas context
    state.canvas = document.getElementById('face-canvas');
    state.ctx = state.canvas.getContext('2d');
    
    // Set canvas size to match container
    const container = document.getElementById('canvas-wrapper');
    state.canvasWidth = container.clientWidth;
    state.canvasHeight = container.clientHeight;
    state.canvas.width = state.canvasWidth;
    state.canvas.height = state.canvasHeight;
    
    document.getElementById('calib-indicator').textContent = "Uncalibrated (px)";
    document.getElementById('results-container').style.display = 'none';
    document.getElementById('empty-state').style.display = 'block';
    document.getElementById('missing-teeth-section').style.display = 'none';
    
    draw();
    updateSidebar();
}

// Setup Event Listeners
function setupEvents() {
    document.getElementById('file-input').addEventListener('change', handleFile);
    
    const c = state.canvas;
    const wrapper = document.getElementById('canvas-wrapper');
    
    // Resize observer
    new ResizeObserver(() => {
        const container = document.getElementById('canvas-wrapper');
        state.canvasWidth = container.clientWidth;
        state.canvasHeight = container.clientHeight;
        state.canvas.width = state.canvasWidth;
        state.canvas.height = state.canvasHeight;
        
        if(state.img) {
            fitImageToScreen();
        }
    }).observe(wrapper);

    // Zoom
    c.addEventListener('wheel', handleWheel, { passive: false });
    
    // Mouse events
    c.addEventListener('mousedown', handleMouseDown);
    c.addEventListener('contextmenu', handleContextMenu);
    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('mouseup', handleMouseUp);
    
    // Close context menu on click outside
    document.addEventListener('click', (e) => {
        const menu = document.getElementById('context-menu');
        if (menu && !menu.contains(e.target)) {
            hideContextMenu();
        }
    });
}

// --- IMAGE HANDLING ---
function handleFile(e) {
    if(!e.target.files[0]) return;
    const reader = new FileReader();
    reader.onload = (evt) => {
        const img = new Image();
        img.onload = () => {
            state.img = img;
            
            // Set canvas size
            const container = document.getElementById('canvas-wrapper');
            state.canvasWidth = container.clientWidth;
            state.canvasHeight = container.clientHeight;
            state.canvas.width = state.canvasWidth;
            state.canvas.height = state.canvasHeight;
            
            init();
            fitImageToScreen();
            document.getElementById('upload-overlay').style.display = 'none';
        };
        img.src = evt.target.result;
    };
    reader.readAsDataURL(e.target.files[0]);
}

// --- Auto-load support (Photo Grid -> Workflow) ---
function rrzLoadImageDataUrl(dataUrl, opts){
    try{
        const img = new Image();
        img.onload = () => {
            state.img = img;

            // Set canvas size
            const container = document.getElementById('canvas-wrapper');
            state.canvasWidth = container.clientWidth;
            state.canvasHeight = container.clientHeight;
            state.canvas.width = state.canvasWidth;
            state.canvas.height = state.canvasHeight;

            init();
            fitImageToScreen();
            document.getElementById('upload-overlay').style.display = 'none';

            if(opts && opts.autocal){
                try{ openCalibrationSettings(true); }catch(e){}
            }
        };
        img.src = dataUrl;
    }catch(e){}
}

async function rrzLoadFromClinicalPhotosDB(slotId){
    // Reads the same IndexedDB used by photo.html: DB_NAME='rrz_clinical_photos_db', store='images', keyPath='id'
    return new Promise((resolve) => {
        try{
            const req = indexedDB.open('rrz_clinical_photos_db', 1);
            req.onerror = () => resolve(null);
            req.onsuccess = () => {
                const db = req.result;
                try{
                    const tx = db.transaction('images', 'readonly');
                    const getReq = tx.objectStore('images').get(String(slotId||''));
                    getReq.onerror = () => { try{db.close();}catch(e){} resolve(null); };
                    getReq.onsuccess = () => {
                        const rec = getReq.result;
                        if(rec && rec.blob){
                            const fr = new FileReader();
                            fr.onload = () => { try{db.close();}catch(e){} resolve(String(fr.result||'')); };
                            fr.onerror = () => { try{db.close();}catch(e){} resolve(null); };
                            fr.readAsDataURL(rec.blob);
                        }else{
                            try{db.close();}catch(e){}
                            resolve(null);
                        }
                    };
                }catch(e){
                    try{db.close();}catch(e2){}
                    resolve(null);
                }
            };
        }catch(e){
            resolve(null);
        }
    });
}

async function rrzAutoLoadFromPhoto(){
    try{
        const qs = new URLSearchParams(location.search);
        const from = qs.get('from') || '';
        const slot = qs.get('slot') || '';
        const autocal = qs.get('autocal') === '1';
        if(!(from === 'photo' || slot)) return;

        const keys = [
            `rrz_${slot}_image`,
            `rrz_${slot}_image_dataurl`,
            'rrz_uploaded_image',
            'uploadedImageDataUrl',
            'selectedImageDataUrl'
        ];

        let dataUrl = null;
        for(const k of keys){
            try{
                const v = sessionStorage.getItem(k);
                if(v && typeof v === 'string' && v.startsWith('data:image')){ dataUrl = v; break; }
            }catch(e){}
        }

        // Robust fallback: load from Photo Grid IndexedDB if sessionStorage is unavailable/too large
        if(!dataUrl && slot){
            dataUrl = await rrzLoadFromClinicalPhotosDB(slot);
        }

        if(dataUrl){
            rrzLoadImageDataUrl(dataUrl, { autocal });
        }
    }catch(e){}
}

function fitImageToScreen() {
    if(!state.img) return;
    
    const imgWidth = state.img.width;
    const imgHeight = state.img.height;
    
    // Calculate scale to fit image in canvas
    const scaleX = state.canvasWidth / imgWidth;
    const scaleY = state.canvasHeight / imgHeight;
    const scale = Math.min(scaleX, scaleY) * 0.9; // 90% to have some margin
    
    view.scale = scale;
    
    // Center the image
    view.offsetX = (state.canvasWidth - imgWidth * scale) / 2;
    view.offsetY = (state.canvasHeight - imgHeight * scale) / 2;
    
    draw();
}

// --- FIXED: Mouse Coordinate Transformation ---
function getImageCoordinates(clientX, clientY) {
    // Get canvas position
    const rect = state.canvas.getBoundingClientRect();
    
    // Get mouse position relative to canvas
    const mouseX = clientX - rect.left;
    const mouseY = clientY - rect.top;
    
    // Convert to image coordinates (inverse of view transform)
    const imgX = (mouseX - view.offsetX) / view.scale;
    const imgY = (mouseY - view.offsetY) / view.scale;
    
    return { x: imgX, y: imgY };
}

// --- ZOOM & PAN LOGIC ---
function handleWheel(e) {
    if(!state.img) return;
    e.preventDefault();
    
    const zoomIntensity = 0.1;
    const delta = e.deltaY > 0 ? -1 : 1;
    const newScale = view.scale * (1 + delta * zoomIntensity);
    
    if (newScale < 0.1 || newScale > 10) return;

    // Get mouse position in canvas coordinates
    const rect = state.canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    // Calculate mouse position in image coordinates before zoom
    const imgX = (mouseX - view.offsetX) / view.scale;
    const imgY = (mouseY - view.offsetY) / view.scale;

    // Apply new scale
    view.scale = newScale;

    // Adjust offset so mouse stays on same image point
    view.offsetX = mouseX - imgX * view.scale;
    view.offsetY = mouseY - imgY * view.scale;

    draw();
}

function handleMouseDown(e) {
    if(!state.img) return;
    
    if(e.button === 2) { // Right click - handled by contextmenu event
        return;
    }
    
    const coords = getImageCoordinates(e.clientX, e.clientY);
    
    // Check if clicking on an existing point to move it
    let pointClicked = -1;
    let minDist = 15 / view.scale; // Click threshold
    
    for(let i = 0; i < state.points.length; i++) {
        if(state.points[i] && !state.missingTeeth[i]) {
            const dist = Math.hypot(state.points[i].x - coords.x, state.points[i].y - coords.y);
            if(dist < minDist) {
                minDist = dist;
                pointClicked = i;
            }
        }
    }
    
    if(pointClicked !== -1) {
        // Start dragging this point
        state.draggingPoint = pointClicked;
        document.getElementById('canvas-wrapper').style.cursor = 'move';
        e.preventDefault();
        return;
    }
    
    // Otherwise, start panning or placing new point
    view.isDragging = false;
    view.startX = e.clientX;
    view.startY = e.clientY;
    view.lastX = e.clientX;
    view.lastY = e.clientY;
    
    e.preventDefault();
}

function handleMouseMove(e) {
    if(!state.img) return;
    
    // If dragging a point
    if(state.draggingPoint !== null) {
        const coords = getImageCoordinates(e.clientX, e.clientY);
        
        // Update point position
        state.points[state.draggingPoint] = { x: coords.x, y: coords.y };
        
        draw();
        return;
    }
    
    // Check if we're dragging (panning)
    if(e.buttons === 1 && (view.isDragging || Math.abs(e.clientX - view.startX) > 5 || Math.abs(e.clientY - view.startY) > 5)) {
        view.isDragging = true;
        
        const dx = e.clientX - view.lastX;
        const dy = e.clientY - view.lastY;
        
        view.offsetX += dx;
        view.offsetY += dy;
        
        view.lastX = e.clientX;
        view.lastY = e.clientY;
        
        draw();
    }
}

function handleMouseUp(e) {
    if(!state.img) return;
    
    // If we were dragging a point, stop dragging
    if(state.draggingPoint !== null) {
        state.draggingPoint = null;
        document.getElementById('canvas-wrapper').style.cursor = 'grab';
        
        // Update analysis if we have enough points
        if(state.currIdx >= 7) {
            analyze();
        }
        return;
    }
    
    // Left click to place new point (only if not dragging)
    if(e.button === 0 && !view.isDragging && state.draggingPoint === null) {
        const coords = getImageCoordinates(e.clientX, e.clientY);
        
        // Check if coordinates are within image bounds
        if(state.img && 
           coords.x >= 0 && coords.x <= state.img.width &&
           coords.y >= 0 && coords.y <= state.img.height) {
            
            if(state.currIdx < LANDMARKS.length) {
                state.points[state.currIdx] = {x: coords.x, y: coords.y};
                state.currIdx++;
                draw();
                updateSidebar();
            }
        }
    }
    
    view.isDragging = false;
}

// --- CONTEXT MENU FOR MISSING TEETH ---
function handleContextMenu(e) {
    e.preventDefault();
    
    if(!state.img) return;
    
    const coords = getImageCoordinates(e.clientX, e.clientY);
    
    // Find closest point
    let closestIdx = -1;
    let minDist = 20 / view.scale; // Threshold distance
    
    state.points.forEach((p, idx) => {
        if(p && !state.missingTeeth[idx]) {
            const dist = Math.hypot(p.x - coords.x, p.y - coords.y);
            if(dist < minDist) {
                minDist = dist;
                closestIdx = idx;
            }
        }
    });
    
    if(closestIdx !== -1) {
        contextMenuPoint = closestIdx;
        showContextMenu(e.clientX, e.clientY);
    }
}

function showContextMenu(x, y) {
    const menu = document.getElementById('context-menu');
    menu.style.display = 'block';
    menu.style.left = x + 'px';
    menu.style.top = y + 'px';
}

function hideContextMenu() {
    document.getElementById('context-menu').style.display = 'none';
    contextMenuPoint = null;
}

function markAsMissing() {
    if(contextMenuPoint !== null) {
        state.missingTeeth[contextMenuPoint] = true;
        hideContextMenu();
        draw();
        updateSidebar();
        updateMissingTeethDisplay();
        
        // Re-analyze if we have enough points
        if(state.currIdx >= 7) {
            analyze();
        }
    }
}

function editPoint() {
    if(contextMenuPoint !== null) {
        state.draggingPoint = contextMenuPoint;
        hideContextMenu();
        document.getElementById('canvas-wrapper').style.cursor = 'move';
    }
}

function deletePoint() {
    if(contextMenuPoint !== null) {
        state.points[contextMenuPoint] = null;
        state.missingTeeth[contextMenuPoint] = false;
        
        // If this was the current point, decrement currIdx
        if(contextMenuPoint === state.currIdx - 1) {
            state.currIdx--;
        }
        
        hideContextMenu();
        draw();
        updateSidebar();
        updateMissingTeethDisplay();
        
        // Re-analyze if we have enough points
        if(state.currIdx >= 7) {
            analyze();
        }
    }
}

// --- DRAWING ---
function draw() {
    const ctx = state.ctx;
    const w = state.canvas.width;
    const h = state.canvas.height;
    
    // Clear canvas
    ctx.clearRect(0, 0, w, h);
    
    // Draw background pattern
    ctx.fillStyle = '#cbd5e1';
    ctx.fillRect(0, 0, w, h);
    
    // Apply view transform
    ctx.save();
    ctx.translate(view.offsetX, view.offsetY);
    ctx.scale(view.scale, view.scale);
    
    // Draw image if exists
    if(state.img) {
        ctx.drawImage(state.img, 0, 0);
    }
    
    // Draw anatomical reference axis (Midline Posterior ‚Üî Midline Anterior) when both points exist
    const pMidPost = state.points[0];
    const pMidAnt  = state.points[1];
    if(pMidPost && pMidAnt && !state.missingTeeth[0] && !state.missingTeeth[1]) {
        ctx.beginPath();
        ctx.moveTo(pMidPost.x, pMidPost.y);
        ctx.lineTo(pMidAnt.x, pMidAnt.y);
        ctx.strokeStyle = '#f59e0b';
        ctx.lineWidth = 2.5 / view.scale;
        ctx.setLineDash([8 / view.scale, 6 / view.scale]);
        ctx.stroke();
        ctx.setLineDash([]);

        // Label
        const lx = (pMidPost.x + pMidAnt.x) / 2;
        const ly = (pMidPost.y + pMidAnt.y) / 2;
        ctx.fillStyle = '#92400e';
        ctx.font = `bold ${12 / view.scale}px Arial`;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'bottom';
        ctx.fillText('Anatomical Axis', lx + (6 / view.scale), ly - (6 / view.scale));
    }

    // Draw arch curve if analysis was done
    if(state.archPoints.length > 2) {
        drawArchCurve();
    }
    
    // Draw measurement lines
    if(state.showMeasurements && state.measurements.length > 0) {
        drawMeasurementLines();
    }
    
    // Draw points
    state.points.forEach((p, i) => {
        if(!p) return;
        
        if(state.missingTeeth[i]) {
            // Draw X for missing teeth
            const size = 10 / view.scale;
            ctx.beginPath();
            ctx.moveTo(p.x - size, p.y - size);
            ctx.lineTo(p.x + size, p.y + size);
            ctx.moveTo(p.x + size, p.y - size);
            ctx.lineTo(p.x - size, p.y + size);
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 3 / view.scale;
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(p.x, p.y, 8 / view.scale, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(239, 68, 68, 0.3)';
            ctx.fill();
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 2 / view.scale;
            ctx.stroke();
        } else {
            // Highlight point being dragged
            const isDragging = i === state.draggingPoint;
            const pointSize = isDragging ? 12 / view.scale : 10 / view.scale;
            
            // Outer circle
            ctx.beginPath();
            ctx.arc(p.x, p.y, pointSize + 2, 0, Math.PI * 2);
            ctx.fillStyle = isDragging ? 'rgba(59, 130, 246, 0.5)' : 'rgba(0, 0, 0, 0.3)';
            ctx.fill();
            
            // Inner circle with color
            ctx.beginPath();
            ctx.arc(p.x, p.y, pointSize, 0, Math.PI * 2);
            ctx.fillStyle = LANDMARKS[i].color;
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(p.x, p.y, pointSize - 2, 0, Math.PI * 2);
            ctx.fillStyle = 'white';
            ctx.fill();
            
            // Number
            ctx.fillStyle = 'black';
            ctx.font = `bold ${12 / view.scale}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(i + 1, p.x, p.y);
        }
    });
    
    ctx.restore();
}

function drawArchCurve() {
    const ctx = state.ctx;
    if(state.archPoints.length < 3) return;

    // NOTE: draw() already applies the view transform (translate + scale).
    // So we draw in image coordinates directly here to avoid double-transform issues.
    ctx.save();

    // Draw arch as smooth curve (Catmull-Rom spline)
    ctx.beginPath();
    ctx.moveTo(state.archPoints[0].x, state.archPoints[0].y);

    for(let i = 0; i < state.archPoints.length - 1; i++) {
        const p0 = i > 0 ? state.archPoints[i-1] : state.archPoints[i];
        const p1 = state.archPoints[i];
        const p2 = state.archPoints[i+1];
        const p3 = i < state.archPoints.length - 2 ? state.archPoints[i+2] : p2;

        // Catmull-Rom spline calculation
        const tension = 0.5;
        const t0x = (p2.x - p0.x) * tension;
        const t0y = (p2.y - p0.y) * tension;
        const t1x = (p3.x - p1.x) * tension;
        const t1y = (p3.y - p1.y) * tension;

        // Draw cubic bezier curve
        ctx.bezierCurveTo(
            p1.x + t0x/3, p1.y + t0y/3,
            p2.x - t1x/3, p2.y - t1y/3,
            p2.x, p2.y
        );
    }

    ctx.strokeStyle = 'rgba(59, 130, 246, 0.8)';
    ctx.lineWidth = 3 / view.scale;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.stroke();

    // Draw points along the arch curve
    state.archPoints.forEach((point) => {
        ctx.beginPath();
        ctx.arc(point.x, point.y, 4 / view.scale, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.fill();
        ctx.strokeStyle = '#3b82f6';
        ctx.lineWidth = 1.5 / view.scale;
        ctx.stroke();
    });

    ctx.restore();
}

function drawMeasurementLines() {
    const ctx = state.ctx;

    // NOTE: draw() already applies the view transform (translate + scale).
    // So we draw in image coordinates directly here to avoid double-transform issues.
    ctx.save();

    state.measurements.forEach(measurement => {
        const { p1, p2, color, label, value, unit } = measurement;

        // Draw line
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.strokeStyle = color;
        ctx.lineWidth = 2 / view.scale;
        ctx.setLineDash([5 / view.scale, 3 / view.scale]);
        ctx.stroke();
        ctx.setLineDash([]);

        // Draw measurement label near the actual segment (midpoint in image coordinates)
        const midX = (p1.x + p2.x) / 2;
        const midY = (p1.y + p2.y) / 2;

        ctx.font = `bold ${12 / view.scale}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // Background for text
        const text = `${label}: ${value}${unit}`;
        const textWidth = ctx.measureText(text).width;
        const padding = 4 / view.scale;

        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(
            midX - textWidth/2 - padding,
            midY - 10/view.scale,
            textWidth + padding*2,
            20/view.scale
        );

        ctx.fillStyle = 'white';
        ctx.fillText(text, midX, midY);
    });

    ctx.restore();
}

// --- SIDEBAR MANAGEMENT ---
function updateSidebar() {
    const list = document.getElementById('points-list');
    list.innerHTML = '';
    
    const placedRequired = state.points.reduce((acc, pt, idx) => {
        if(pt && !LANDMARKS[idx].optional) acc++;
        return acc;
    }, 0);
    document.getElementById('points-counter').textContent = `${placedRequired}/${REQUIRED_COUNT}`;
    
    LANDMARKS.forEach((l, i) => {
        const li = document.createElement('li');
        let className = 'point-item';
        if(l.optional) className += ' optional';
        if(i === state.currIdx) className += ' active';
        if(state.points[i]) className += ' done';
        if(state.missingTeeth[i]) className += ' missing';
        
        li.className = className;
        li.onclick = () => {
            // Allow selecting point for editing
            if(state.points[i]) {
                state.draggingPoint = i;
                document.getElementById('canvas-wrapper').style.cursor = 'move';
                updateSidebar();
            }
        };
        
        li.innerHTML = `
            <span>
                <span class="point-marker" style="background:${l.color}"></span>
                ${l.name}
            </span>
            ${state.points[i] ? (state.missingTeeth[i] ? '‚úï' : '‚úì') : ''}
        `;
        list.appendChild(li);
    });
}

function updateMissingTeethDisplay() {
    const missingCount = state.missingTeeth.filter(m => m).length;
    if(missingCount > 0) {
        document.getElementById('missing-teeth-section').style.display = 'block';
        document.getElementById('missing-count').textContent = missingCount;
        
        const missingNames = state.missingTeeth
            .map((m, i) => m ? LANDMARKS[i].name.split('. ')[1] : null)
            .filter(name => name);
        
        document.getElementById('missing-list').textContent = missingNames.join(', ') || 'None';
    } else {
        document.getElementById('missing-teeth-section').style.display = 'none';
    }
}

// --- ANALYSIS FUNCTIONS ---
function analyze() {
    if(state.currIdx < 7) { // Need at least basic points
        alert("Please place at least the midline and first molars/canines.");
        return;
    }

    const p = state.points;
    const ppm = state.ppm || 1;
    const unit = state.ppm ? 'mm' : 'px';
    
    // Calculate distances
    const dist = (p1, p2) => {
        if(!p1 || !p2) return 0;
        return Math.hypot(p1.x - p2.x, p1.y - p2.y) / ppm;
    };
    
    // Clear previous measurements
    state.measurements = [];
    
    // 1. Dental Midline to Midline Posterior (Points 3 to 1)
    let midlineLength = 0;
    if(p[2] && p[0]) {
        midlineLength = dist(p[2], p[0]);
        state.measurements.push({
            p1: p[2],
            p2: p[0],
            color: '#ef4444',
            label: 'Midline Length',
            value: midlineLength.toFixed(1),
            unit: unit
        });
    }
    
    // 2. R Canine to L Canine (Points 6 to 13)
    let icw = 0;
    if(p[5] && !state.missingTeeth[5] && p[12] && !state.missingTeeth[12]) {
        icw = dist(p[5], p[12]);
        state.measurements.push({
            p1: p[5],
            p2: p[12],
            color: '#3b82f6',
            label: 'ICW',
            value: icw.toFixed(1),
            unit: unit
        });
    }
    
    // 3. R Molar Cusp to L Molar Cusp (Points 10 to 17)
    let imwCusp = 0;
    if(p[9] && !state.missingTeeth[9] && p[16] && !state.missingTeeth[16]) {
        imwCusp = dist(p[9], p[16]);
        state.measurements.push({
            p1: p[9],
            p2: p[16],
            color: '#8b5cf6',
            label: 'IMW Cusp',
            value: imwCusp.toFixed(1),
            unit: unit
        });
    }
    
    // 4. Intermolar Width (Fossa) - Points 9 to 16
    let imw = 0;
    if(p[8] && !state.missingTeeth[8] && p[15] && !state.missingTeeth[15]) {
        imw = dist(p[8], p[15]);
        state.measurements.push({
            p1: p[8],
            p2: p[15],
            color: '#10b981',
            label: 'IMW Fossa',
            value: imw.toFixed(1),
            unit: unit
        });
    }
    
    // 5. Premolar Width (Points 7 to 14)
    let pmw = 0;
    if(p[6] && !state.missingTeeth[6] && p[13] && !state.missingTeeth[13]) {
        pmw = dist(p[6], p[13]);
    }
    
    // Midline Deviation Calculation
    let midlineDev = 0;
    let midlineDir = "Centered";
    if(p[0] && p[1] && p[2]) {
        const vx = p[1].x - p[0].x;
        const vy = p[1].y - p[0].y;
        const mag = Math.hypot(vx, vy);
        if(mag > 0) {
            const wx = p[2].x - p[0].x;
            const wy = p[2].y - p[0].y;
            const cross = (vx * wy - vy * wx);
            midlineDev = Math.abs(cross / mag / ppm);
            midlineDir = cross > 0 ? "Right" : "Left";
        }
    }
    
    // Arch Form Calculation
    let archForm = "Ovoid";
    let archRatio = 0;
    if(imw > 0 && icw > 0) {
        archRatio = imw / icw;
        if(archRatio > 1.4) archForm = "Square";
        else if(archRatio < 1.2) archForm = "Tapered";
        else archForm = "Ovoid";
    }
    
    // Arch Symmetry
    let symmetry = 100;
    if(p[5] && p[12] && p[2]) {
        const rightDist = dist(p[5], p[2]);
        const leftDist = dist(p[12], p[2]);
        if(Math.max(rightDist, leftDist) > 0) {
            symmetry = Math.min(rightDist, leftDist) / Math.max(rightDist, leftDist) * 100;
        }
    }
    
    // Arch Deformity Analysis
    let deformity = "Normal";
    if(midlineDev > 2.0 || symmetry < 80) {
        deformity = "Moderate";
    }
    if(midlineDev > 3.0 || symmetry < 70) {
        deformity = "Severe";
    }
    
    // Generate arch points for drawing curve from point 9 to 16
    generateArchPoints();
    
    // Show measurements
    state.showMeasurements = true;
    
    // Update UI
    document.getElementById('midline-length-val').textContent = midlineLength > 0 ? midlineLength.toFixed(1) + " " + unit : "--";
    document.getElementById('icw-val').textContent = icw > 0 ? icw.toFixed(1) + " " + unit : "--";
    document.getElementById('imw-cusp-val').textContent = imwCusp > 0 ? imwCusp.toFixed(1) + " " + unit : "--";
    document.getElementById('imw-val').textContent = imw > 0 ? imw.toFixed(1) + " " + unit : "--";
    document.getElementById('pmw-val').textContent = pmw > 0 ? pmw.toFixed(1) + " " + unit : "--";
    
    document.getElementById('midline-val').textContent = midlineDev.toFixed(1) + " " + unit;
    document.getElementById('midline-dir').textContent = midlineDev < 0.5 ? "Centered" : midlineDir + " side";
    document.getElementById('midline-card').className = midlineDev > 1.5 ? "metric-card alert" : "metric-card";
    
    document.getElementById('sym-val').textContent = symmetry.toFixed(0) + "%";
    
    // Update arch form display
    const archTag = document.getElementById('arch-form-tag');
    archTag.textContent = archForm;
    if(archForm === 'Square') {
        archTag.className = 'tag green';
    } else if(archForm === 'Tapered') {
        archTag.className = 'tag orange';
    } else {
        archTag.className = 'tag blue';
    }
    
    document.getElementById('arch-ratio-val').textContent = `Width/Depth Ratio: ${archRatio > 0 ? archRatio.toFixed(2) : '--'}`;
    document.getElementById('arch-rec').textContent = `Form: ${archForm} Arch`;
    
    // Update deformity display
    const deformityTag = document.getElementById('deformity-tag');
    deformityTag.textContent = deformity;
    if(deformity === 'Severe') {
        deformityTag.className = 'tag red';
    } else if(deformity === 'Moderate') {
        deformityTag.className = 'tag orange';
    } else {
        deformityTag.className = 'tag green';
    }
    
    // Generate recommendations
    generateRecommendations();
    
    // Show results
    document.getElementById('results-container').style.display = 'block';
    document.getElementById('empty-state').style.display = 'none';
    
    draw();
}

function generateArchPoints() {
    state.archPoints = [];
    
    // Define the order of points for arch curve (from point 9 to 16, R molar fossa to L molar fossa)
    // This includes all teeth points in between
    const archOrder = [
        17, // 18. R 2nd Molar Fossa (Optional)
        8,  // 9. R 1st Molar Fossa
        7,  // 8. R 2nd Premolar Fossa
        6,  // 7. R 1st Premolar Fossa
        5,  // 6. R Canine
        4,  // 5. R Lateral Incisor
        3,  // 4. R Central Incisor
        2,  // 3. Dental Midline
        10, // 11. L Central Incisor
        11, // 12. L Lateral Incisor
        12, // 13. L Canine
        13, // 14. L 1st Premolar Fossa
        14, // 15. L 2nd Premolar Fossa
        15, // 16. L 1st Molar Fossa
        18  // 19. L 2nd Molar Fossa (Optional)
    ];
    
    // Add points in order if they exist and aren't missing
    archOrder.forEach(idx => {
        if(state.points[idx] && !state.missingTeeth[idx]) {
            state.archPoints.push(state.points[idx]);
        }
    });
}

function generateRecommendations() {
    const recommendations = [];
    const missingCount = state.missingTeeth.filter(m => m).length;
    
    if(missingCount > 0) {
        recommendations.push(`‚Ä¢ ${missingCount} missing teeth detected - consider space analysis for replacement`);
    }
    
    const midlineVal = parseFloat(document.getElementById('midline-val').textContent) || 0;
    if(midlineVal > 2.0) {
        recommendations.push(`‚Ä¢ Midline deviation of ${midlineVal.toFixed(1)}mm requires correction`);
    }
    
    const archForm = document.getElementById('arch-form-tag').textContent;
    if(archForm === 'Tapered') {
        recommendations.push(`‚Ä¢ Tapered arch form may benefit from expansion therapy`);
    } else if(archForm === 'Square') {
        recommendations.push(`‚Ä¢ Square arch form is well-developed`);
    }
    
    const deformity = document.getElementById('deformity-tag').textContent;
    if(deformity === 'Severe') {
        recommendations.push(`‚Ä¢ Severe arch deformity requires comprehensive orthodontic evaluation`);
    } else if(deformity === 'Moderate') {
        recommendations.push(`‚Ä¢ Moderate arch deformity should be monitored`);
    }
    
    document.getElementById('recommendations').innerHTML = 
        recommendations.length > 0 ? 
        recommendations.join('<br>') : 
        'Arch form and alignment appear within normal limits.';
}

// --- UNDO & RESET FUNCTIONS ---
function undoPoint() {
    if(state.currIdx > 0) {
        state.currIdx--;
        state.points[state.currIdx] = null;
        state.missingTeeth[state.currIdx] = false;
        state.draggingPoint = null;
        document.getElementById('canvas-wrapper').style.cursor = 'grab';
        draw();
        updateSidebar();
        updateMissingTeethDisplay();
    }
}

function resetAll() {
    if(confirm("Are you sure you want to reset all points and measurements?")) {
        init();
    }
}

// --- CALIBRATION ---
function openCalibration(force=false) {
    // Legacy manual calibration modal (requires points), but allow forcing open when needed
    if(!force && state.currIdx < 2) {
        alert("Place at least two corresponding points first.");
        return;
    }
    document.getElementById('calib-modal').style.display = 'block';
}

// Calibration Settings (Manual vs Pixel)
function openCalibrationSettings(forceOpen=false){
    const m = document.getElementById('calib-settings-modal');
    if(!m) return;
    m.style.display = 'block';
    updateCalibSettingsUI();
    // Optional hint when opening automatically
    const hint = document.getElementById('calib-settings-hint');
    if(hint){
        hint.textContent = forceOpen ? 'Select a calibration method. You can calibrate now or later before analysis.' : '';
    }
}

function closeCalibrationSettings(){
    const m = document.getElementById('calib-settings-modal');
    if(m) m.style.display = 'none';
}

function updateCalibSettingsUI(){
    const manual = document.querySelector('input[name="calib-method"]:checked');
    const mode = manual ? manual.value : 'manual';
    const pxFields = document.getElementById('pixel-calib-fields');
    if(pxFields) pxFields.style.display = (mode==='pixel') ? 'block' : 'none';
    const optM = document.getElementById('calib-opt-manual');
    const optP = document.getElementById('calib-opt-pixel');
    if(optM && optP){
        optM.classList.toggle('selected', mode==='manual');
        optP.classList.toggle('selected', mode==='pixel');
    }

}

function invertPxMm(){
    const inp = document.getElementById('px-per-mm');
    if(!inp) return;
    const v = parseFloat(inp.value);
    if(!v || v<=0) return;
    inp.value = (1.0 / v).toFixed(6);
}

function applyCalibrationSettings(){
    const sel = document.querySelector('input[name="calib-method"]:checked');
    const mode = sel ? sel.value : 'manual';
    const hint = document.getElementById('calib-settings-hint');
    if(mode==='pixel'){
        const v = parseFloat(document.getElementById('px-per-mm')?.value);
        if(!v || v<=0){
            if(hint) hint.textContent = 'Enter a valid scale value.';
            alert('Please enter a valid px-per-mm value.');
            return;
        }
        state.ppm = v;
        if(hint) hint.textContent = `Applied: ${v.toFixed(4)} px/mm`;
        closeCalibrationSettings();
        draw();
        return;
    }
    // Manual mode: if points are ready, open the manual modal; otherwise just close and allow point placement.
    if(state.currIdx >= 2){
        closeCalibrationSettings();
        openCalibration(true);
    }else{
        if(hint) hint.textContent = 'Place the relevant points first, then open Calibration again to input the real distance.';
        // Keep the settings modal open for guidance, but do not block the workflow.
    }
}


function applyCalibration() {
    const mm = parseFloat(document.getElementById('known-mm').value);
    const type = document.getElementById('calib-ref-type').value;
    
    if(!mm || mm <= 0) {
        alert("Please enter a valid distance in mm.");
        return;
    }
    
    let p1, p2;
    switch(type) {
        case 'icw':
            p1 = state.points[5]; // R canine
            p2 = state.points[12]; // L canine
            break;
        case 'imw':
            p1 = state.points[8]; // R 1st molar fossa
            p2 = state.points[15]; // L 1st molar fossa
            break;
        case 'imw-cusp':
            p1 = state.points[9]; // R 1st molar cusp
            p2 = state.points[16]; // L 1st molar cusp
            break;
        case 'midline':
            p1 = state.points[2]; // Dental midline
            p2 = state.points[0]; // Midline posterior
            break;
    }
    
    if(!p1 || !p2) {
        alert("Selected points are not placed yet.");
        return;
    }
    
    const pixelDist = Math.hypot(p1.x - p2.x, p1.y - p2.y);
    state.ppm = pixelDist / mm;
    
    document.getElementById('calib-indicator').textContent = `Calibrated (1mm = ${state.ppm.toFixed(2)}px)`;
    closeModal('calib-modal');
    
    analyze();
}

// --- MODAL FUNCTIONS ---
function openRefGuide() {
    document.getElementById('ref-modal').style.display = 'block';
}

function closeModal(modalId) {
    document.getElementById(modalId).style.display = 'none';
}

// --- PDF EXPORT ---
async function exportPDF() {
    if(state.currIdx < 7) {
        alert("Please complete analysis before exporting.");
        return;
    }
    
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF('p', 'mm', 'a4');
    
    // Title
    doc.setFontSize(20);
    doc.setTextColor(44, 62, 80);
    doc.text('Occlusal Analysis Report', 105, 20, null, null, 'center');
    
    // Date and Info
    doc.setFontSize(10);
    doc.setTextColor(100, 100, 100);
    doc.text(`Date: ${new Date().toLocaleDateString()}`, 20, 30);
    doc.text(`Analysis Type: Complete Occlusal Assessment`, 20, 36);
    
    // Capture canvas as image
    try {
        const canvas = document.getElementById('face-canvas');
        const imgData = await html2canvas(canvas).then(canvas => canvas.toDataURL('image/png'));
        
        // Add image
        const imgWidth = 170;
        const imgHeight = (canvas.height * imgWidth) / canvas.width;
        doc.addImage(imgData, 'PNG', 20, 45, imgWidth, imgHeight);
        
        // Analysis Results
        let yPos = imgHeight + 55;
        
        doc.setFontSize(14);
        doc.setTextColor(44, 62, 80);
        doc.text('Analysis Results', 20, yPos);
        yPos += 10;
        
        doc.setFontSize(10);
        doc.setTextColor(0, 0, 0);
        
        // Width Measurements
        doc.text(`Midline Length: ${document.getElementById('midline-length-val').textContent}`, 20, yPos);
        yPos += 6;
        doc.text(`Intercanine Width (ICW): ${document.getElementById('icw-val').textContent}`, 20, yPos);
        yPos += 6;
        doc.text(`Intermolar Width (Cusp): ${document.getElementById('imw-cusp-val').textContent}`, 20, yPos);
        yPos += 6;
        doc.text(`Intermolar Width (Fossa): ${document.getElementById('imw-val').textContent}`, 20, yPos);
        yPos += 6;
        doc.text(`Premolar Width: ${document.getElementById('pmw-val').textContent}`, 20, yPos);
        yPos += 8;
        
        // Arch Form
        doc.text(`Arch Form: ${document.getElementById('arch-form-tag').textContent}`, 20, yPos);
        yPos += 6;
        doc.text(`Arch Ratio: ${document.getElementById('arch-ratio-val').textContent.split(': ')[1]}`, 20, yPos);
        yPos += 8;
        
        // Midline and Symmetry
        doc.text(`Midline Deviation: ${document.getElementById('midline-val').textContent}`, 20, yPos);
        yPos += 6;
        doc.text(`Direction: ${document.getElementById('midline-dir').textContent}`, 20, yPos);
        yPos += 6;
        doc.text(`Arch Symmetry: ${document.getElementById('sym-val').textContent}`, 20, yPos);
        yPos += 8;
        
        // Missing Teeth
        const missingCount = state.missingTeeth.filter(m => m).length;
        if(missingCount > 0) {
            doc.setTextColor(220, 53, 69);
            doc.text(`Missing Teeth: ${missingCount}`, 20, yPos);
            yPos += 6;
            
            const missingNames = state.missingTeeth
                .map((m, i) => m ? LANDMARKS[i].name.split('. ')[1] : null)
                .filter(name => name);
            doc.text(`Missing: ${missingNames.join(', ')}`, 20, yPos);
            yPos += 8;
            doc.setTextColor(0, 0, 0);
        }
        
        // Arch Deformity
        doc.text(`Arch Deformity: ${document.getElementById('deformity-tag').textContent}`, 20, yPos);
        yPos += 10;
        
        // Recommendations
        doc.setFontSize(12);
        doc.setTextColor(23, 162, 184);
        doc.text('Clinical Recommendations:', 20, yPos);
        yPos += 8;
        
        doc.setFontSize(10);
        doc.setTextColor(0, 0, 0);
        const recommendations = document.getElementById('recommendations').textContent.split('\n');
        recommendations.forEach(rec => {
            if(rec.trim()) {
                doc.text(`‚Ä¢ ${rec.trim()}`, 25, yPos);
                yPos += 6;
            }
        });
        

        // RRZ Notes (PDF) (added)
        try{
            const n = (window.rrzGetNotes ? window.rrzGetNotes() : {crowding:'',gingivalMargin:'',gingivalColor:'',otherFindings:''});
            const noteRows = [];
            if(n.crowding) noteRows.push(['Crowding', n.crowding]);
            if(n.gingivalMargin) noteRows.push(['Gingival Margin', n.gingivalMargin]);
            if(n.gingivalColor) noteRows.push(['Gingival color', n.gingivalColor]);
            if(n.otherFindings) noteRows.push(['Other Findings', n.otherFindings]);

            const ensureSpace = (needed=8) => {
                if(yPos + needed > 270){
                    doc.addPage();
                    yPos = 20;
                }
            };

            if(noteRows.length){
                ensureSpace(14);
                try{ doc.setDrawColor(203, 213, 225); }catch(e){}
                try{ doc.line(20, yPos, 190, yPos); }catch(e){}
                yPos += 8;
                ensureSpace(10);
                doc.setFontSize(12);
                doc.setTextColor(44, 62, 80);
                doc.text('Notes:', 20, yPos);
                yPos += 8;

                doc.setFontSize(10);
                doc.setTextColor(0, 0, 0);
                noteRows.forEach(([k,v]) => {
                    const text = `${k}: ${String(v).replace(/\s+/g,' ').trim()}`;
                    const lines = doc.splitTextToSize(text, 165);
                    ensureSpace(lines.length*6 + 2);
                    doc.text(lines, 20, yPos);
                    yPos += lines.length * 6 + 2;
                });
            }
        }catch(e){}

        // Footer
        doc.setFontSize(8);
        doc.setTextColor(150, 150, 150);
        doc.text('Generated by Occlusal AI Analysis System', 105, 280, null, null, 'center');
        
        // Save PDF
        doc.save(`occlusal-analysis-${new Date().toISOString().slice(0,10)}.pdf`);
    } catch (error) {
        alert("Error generating PDF: " + error.message);
    }
}

// Initialize application
window.onload = function() {
    init();
    setupEvents();
    rrzAutoLoadFromPhoto();

    // Ensure PWA works consistently across all workflow pages
    if ('serviceWorker' in navigator) {
        try{ navigator.serviceWorker.register('./sw.js').catch(function(){}); }catch(e){}
    }
};


// === RRZ NOTES HELPERS (added) ===
(function(){
  function rrzNotesSlotKey(){
    try{
      const qs = new URLSearchParams(location.search);
      const slot = qs.get('slot') || '';
      const from = qs.get('from') || '';
      return (slot ? ('slot:'+slot) : '') + (from ? ('|from:'+from) : '');
    }catch(e){
      return '';
    }
  }

  function rrzNotesStorageKey(){
    return 'rrz_photo_notes::' + location.pathname + '::' + rrzNotesSlotKey();
  }

  function rrzReadNotes(){
    const empty = { crowding:'', gingivalMargin:'', gingivalColor:'', otherFindings:'' };
    try{
      const raw = localStorage.getItem(rrzNotesStorageKey());
      if(!raw) return empty;
      const obj = JSON.parse(raw);
      return {
        crowding: (obj.crowding||''),
        gingivalMargin: (obj.gingivalMargin||''),
        gingivalColor: (obj.gingivalColor||''),
        otherFindings: (obj.otherFindings||'')
      };
    }catch(e){
      return empty;
    }
  }

  function rrzWriteNotes(n){
    try{ localStorage.setItem(rrzNotesStorageKey(), JSON.stringify(n||{})); }catch(e){}
  }

  function rrzEscapeHtml(str){
    return String(str||'')
      .replaceAll('&','&amp;')
      .replaceAll('<','&lt;')
      .replaceAll('>','&gt;')
      .replaceAll('"','&quot;')
      .replaceAll("'","&#039;");
  }

  window.rrzGetNotes = function(){
    const n = rrzReadNotes();
    const c = document.getElementById('note-crowding');
    const gm = document.getElementById('note-gingival-margin');
    const gc = document.getElementById('note-gingival-color');
    const of = document.getElementById('note-other-findings');
    if(c) n.crowding = (c.value||'').trim();
    if(gm) n.gingivalMargin = (gm.value||'').trim();
    if(gc) n.gingivalColor = (gc.value||'').trim();
    if(of) n.otherFindings = (of.value||'').trim();
    rrzWriteNotes(n);
    return n;
  };

  window.rrzNotesToPrintHtml = function(){
    const n = window.rrzGetNotes ? window.rrzGetNotes() : rrzReadNotes();
    const rows = [];
    if(n.crowding) rows.push(['Crowding', n.crowding]);
    if(n.gingivalMargin) rows.push(['Gingival Margin', n.gingivalMargin]);
    if(n.gingivalColor) rows.push(['Gingival color', n.gingivalColor]);
    if(n.otherFindings) rows.push(['Other Findings', n.otherFindings]);
    if(!rows.length) return '';
    return `
      <div class="section" style="margin-top:18px;">
        <hr style="border:0; border-top:1px solid #cbd5e1; margin: 14px 0;"/>
        <h3>Notes</h3>
        <table>
          <tr><th>Item</th><th>Value</th></tr>
          ${rows.map(([k,v]) => `<tr><td>${rrzEscapeHtml(k)}</td><td>${rrzEscapeHtml(v)}</td></tr>`).join('')}
        </table>
      </div>
    `;
  };

  window.rrzNotesToReportHtml = function(){
    const n = window.rrzGetNotes ? window.rrzGetNotes() : rrzReadNotes();
    const rows = [];
    if(n.crowding) rows.push(`<div class="p-item"><div class="p-title">Crowding</div><div class="p-value">${rrzEscapeHtml(n.crowding)}</div></div>`);
    if(n.gingivalMargin) rows.push(`<div class="p-item"><div class="p-title">Gingival Margin</div><div class="p-value">${rrzEscapeHtml(n.gingivalMargin)}</div></div>`);
    if(n.gingivalColor) rows.push(`<div class="p-item"><div class="p-title">Gingival color</div><div class="p-value">${rrzEscapeHtml(n.gingivalColor)}</div></div>`);
    if(n.otherFindings) rows.push(`<div class="p-item"><div class="p-title">Other Findings</div><div class="p-value">${rrzEscapeHtml(n.otherFindings)}</div></div>`);
    if(!rows.length) return '';
    return `
      <div style="margin-top:14px;">
        <hr style="border:0; border-top:1px solid #cbd5e1; margin: 14px 0;"/>
        <div style="font-weight:800; margin: 0 0 10px;">Notes</div>
        ${rows.join('')}
      </div>
    `;
  };

  window.rrzInitNotes = function(){
    const panel = document.getElementById('user-notes-panel');
    if(!panel) return;
    const n = rrzReadNotes();
    const c = document.getElementById('note-crowding');
    const gm = document.getElementById('note-gingival-margin');
    const gc = document.getElementById('note-gingival-color');
    const of = document.getElementById('note-other-findings');
    if(c) c.value = n.crowding || '';
    if(gm) gm.value = n.gingivalMargin || '';
    if(gc) gc.value = n.gingivalColor || '';
    if(of) of.value = n.otherFindings || '';

    const saveNow = () => { try{ window.rrzGetNotes && window.rrzGetNotes(); }catch(e){} };
    [c,gm,gc,of].forEach(el => { if(el){ el.addEventListener('input', saveNow); el.addEventListener('change', saveNow); } });

    const toggle = (on) => { panel.style.display = on ? 'block' : 'none'; };

    // Toggle based on common global state flags if present
    try{
      if(typeof state === 'object' && state && ('imageLoaded' in state)) toggle(!!state.imageLoaded);
      else toggle(false);
    }catch(e){ toggle(false); }


    // RRZ_NOTES_VISIBILITY_WATCH: ensure panel appears after auto-load from dashboard/PWA caches.
    (function(){
      let tries = 0;
      const qs = (function(){ try{ return new URLSearchParams(location.search); }catch(e){ return null; } })();
      const openedFromDashboard = !!(qs && ((qs.get('from') === 'photo') || qs.get('slot')));
      const t = setInterval(() => {
        tries++;
        let loaded = false;
        try{ loaded = !!(typeof state === 'object' && state && state.imageLoaded); }catch(e){}
        if (loaded){
          try{ toggle(true); }catch(e){}
          clearInterval(t);
          return;
        }
        // After ~3 seconds: if opened from dashboard, show notes anyway (even if image load failed),
        // so user can still type notes and the page won't look "missing".
        if (tries >= 30){
          if (openedFromDashboard){
            try{ toggle(true); }catch(e){}
          }
          clearInterval(t);
        }
      }, 100);
    })();
    // Hook image upload/reset buttons if present (supports different ids)
    const up = document.getElementById('image-upload') || document.getElementById('file-input');
    if(up){ up.addEventListener('change', () => setTimeout(() => toggle(true), 80)); }

    const ch = document.getElementById('change-img-btn');
    if(ch){ ch.addEventListener('click', () => setTimeout(() => toggle(true), 80)); }

    const rs = document.getElementById('reset-btn');
    if(rs){ rs.addEventListener('click', () => setTimeout(() => {
      try{ if(typeof state === 'object' && state && ('imageLoaded' in state)) toggle(!!state.imageLoaded); }
      catch(e){}
    }, 80)); }

    // If resetAll() exists (some workflows use inline onclick), wrap it once.
    try{
      if(typeof window.resetAll === 'function' && !window.resetAll.__rrz_wrapped){
        const _orig = window.resetAll;
        const _wrap = function(){
          const ret = _orig.apply(this, arguments);
          setTimeout(() => {
            try{ if(typeof state === 'object' && state && ('imageLoaded' in state)) toggle(!!state.imageLoaded); else toggle(false); }
            catch(e){ toggle(false); }
          }, 80);
          return ret;
        };
        _wrap.__rrz_wrapped = true;
        window.resetAll = _wrap;
      }
    }catch(e){}
  };

  document.addEventListener('DOMContentLoaded', function(){
    try{ window.rrzInitNotes && window.rrzInitNotes(); }catch(e){}
  });
})();

</script>
</body>
</html>